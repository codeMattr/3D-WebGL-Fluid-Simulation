{
    "history": [
      {
        "breakpoints": [
          {
            "max": null,
            "min": 992,
            "props": {
              "speed": 0.32,
              "trackMouse": 0,
              "pos": {
                "type": "Vec2",
                "_x": 0.49305236270753516,
                "_y": 0.48915708812260533
              },
              "phase": 0.99,
              "mouseMomentum": 0,
              "gradientAngle": 0.0027,
              "scale": 0.18
            },
            "name": "Desktop"
          },
          {
            "min": 0,
            "props": {
              "speed": 0,
              "scale": 0.66,
              "gradientAngle": 0.3348,
              "trackMouse": 0,
              "pos": {
                "type": "Vec2",
                "_x": 0.49305236270753516,
                "_y": 0.48819923371647506
              },
              "mouseMomentum": 0,
              "phase": 0.86
            },
            "name": "Mobile",
            "max": 575
          }
        ],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "gradient",
        "usesPingPong": false,
        "speed": 0.32,
        "trackMouse": 0,
        "mouseMomentum": 0,
        "animating": false,
        "isMask": 0,
        "compiledFragmentShaders": [
          "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uAngle; uniform float uScale; uniform float uTime; uniform float uPhase; uniform vec2 uPos; uniform float uTrackMouse; uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.3137254901960784, 0, 0.0392156862745098); case 1: return vec3(0.5450980392156862, 0, 0.09411764705882353); case 2: return vec3(0.8196078431372549, 0, 0.1607843137254902); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3 lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) ); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0 + 0.025 * a * (1.0-a); return kLMStoCONE * (lms * lms * lms); }vec3 getGradientColor(float position) { position = clamp(position, 0.0, 1.0); for (int i = 0; i < 3 - 1; i++) { float colorPosition = float(i) / float(3 - 1); float nextColorPosition = float(i + 1) / float(3 - 1); if (position <= nextColorPosition) { float mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart = linear_from_srgb(getColor(i)); vec3 linEnd = linear_from_srgb(getColor(i + 1)); vec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor); return srgb_from_linear(mixedLin); } } return getColor(3 - 1); }out vec4 fragColor;vec3 applyColorToPosition(float position) { vec3 color = vec3(0); position -= (uTime * 0.01 + uPhase); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color += dither; return color; }vec3 linearGrad(vec2 uv) { float position = (uv.x+0.5); return applyColorToPosition(position); }vec3 getGradient(vec2 uv) { return linearGrad(uv); }vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.3137254901960784, 0, 0.0392156862745098); }void main() {vec2 uv = vTextureCoord; vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), uTrackMouse); uv -= pos; uv /= (uScale*2.); uv = rotate(uv, (uAngle - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
        ],
        "data": {
          "depth": false,
          "uniforms": {
            "scale": {
              "name": "uScale",
              "type": "1f",
              "value": 0.5
            },
            "gradientAngle": {
              "name": "uAngle",
              "type": "1f",
              "value": 0.5
            },
            "trackMouse": {
              "name": "uTrackMouse",
              "type": "1f",
              "value": 0
            },
            "pos": {
              "name": "uPos",
              "type": "2f",
              "value": {
                "type": "Vec2",
                "_x": 0.5,
                "_y": 0.5
              }
            },
            "phase": {
              "name": "uPhase",
              "type": "1f",
              "value": 0
            }
          }
        }
      },
      {
        "breakpoints": [],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "spotlight",
        "usesPingPong": false,
        "pos": {
          "type": "Vec2",
          "_x": 0.59,
          "_y": 0.5
        },
        "trackMouse": 0,
        "mouseMomentum": 0,
        "animating": true,
        "isMask": 0,
        "states": {
          "appear": [
            {
              "type": "appear",
              "id": "996e6ead-6545-44c5-bbb7-85b2d26a3c99",
              "prop": "pos",
              "transition": {
                "duration": 1000,
                "delay": 0,
                "ease": "easeInOutQuart"
              },
              "complete": false,
              "progress": 0,
              "value": {
                "type": "Vec2",
                "_x": 0,
                "_y": 0.5
              },
              "endValue": {
                "type": "Vec2",
                "_x": 0.5,
                "_y": 0.5
              },
              "initialized": false,
              "breakpoints": [],
              "uniformData": {
                "type": "2f",
                "name": "uPos"
              }
            }
          ],
          "scroll": [],
          "hover": []
        },
        "compiledFragmentShaders": [
          "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (1.0000 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(1, 0)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
          "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;const int kernelSize = 36;float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float amount = (1.0000 + 0.1) * 2.; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * getGaussianWeight(i); } return color; }vec4 getColor(vec2 uv) { return GaussianBlur(uTexture, uv, vec2(0, 1)); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}",
          "#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uMousePos; uniform vec2 uResolution;uniform vec2 uPos;out vec4 fragColor;const int kernelSize = 36;float getHeight(vec2 uv) { vec4 col = texture(uTexture, uv); return col.r; }vec4 computeNoise(vec2 uv) { vec2 ste = (1. / uResolution); float height = getHeight(uv); vec2 dxy = height - vec2(getHeight(uv + vec2(ste.x, 0.)), getHeight(uv + vec2(0., ste.y)));return vec4(normalize(vec3(dxy * (0.02 + 0.04 * 1.0000) / ste, 2.)), height); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float light(vec3 p, vec3 normal, vec3 lightPos) { vec3 direction = normalize(lightPos - p); float specular = 0.5 * pow(max(dot(direction, reflect(-direction, normal)), 0.0), 2.0); return max(0.1, dot(normal, direction) * 1.2 - specular); }vec4 getPointlight(vec2 uv) { vec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec4 color = texture(uBgTexture, uv); float luma = color.r; float dist = distance(uv * aspectRatio, pos * aspectRatio) / (0.5800 + 0.5); float hightlighDist = distance(uv * aspectRatio, pos * aspectRatio) / (0.5800 + 0.5)/2.; float spot = max(0., max(0., (1.-dist)) * max(0., (1.-dist))); float highlightSpot = max(0., max(0., (1.-hightlighDist)) * max(0., (1.-hightlighDist))); vec3 normal = computeNoise(uv).rgb*luma; vec2 lightDir = pos * aspectRatio - uv * aspectRatio; float lightDistance = 1.-length(lightDir); lightDir = normalize(lightDir); vec3 diff = vec3(max(dot(normal, vec3(lightDir, 0.5)), 0.0));float specular = light(vec3(uv, 1.), normal, vec3(pos, 1.)); specular = smoothstep(0., 1., specular) * 2.; float intensity = 0.9300 * 3.; vec3 base = color.rgb * vec3(1, 1, 1) * max(0., spot) * intensity; color.rgb = color.rgb * 0.7000 + base * diff * vec3(1, 1, 1) * max(0., spot) * intensity; color.rgb += specular * vec3(1, 1, 1) * max(0., spot * 4.) * 1.0000; color.rgb = Tonemap_tanh(color.rgb); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 getColor(vec2 uv) { return getPointlight(uv); }void main() { vec4 clipColor = texture(uTexture, vTextureCoord); if(clipColor.a == 0.) { fragColor = vec4(0); return; }vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "downSample": true,
          "depth": false,
          "uniforms": {},
          "passes": [
            {
              "prop": "pass",
              "value": 1,
              "downSample": true
            },
            {
              "prop": "pass",
              "value": 2,
              "includeBg": true
            }
          ]
        }
      },
      {
        "breakpoints": [],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "liquify",
        "usesPingPong": false,
        "speed": 0.04,
        "trackMouse": 0,
        "mouseMomentum": 0,
        "animating": true,
        "isMask": 0,
        "compiledFragmentShaders": [
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform float uTime; uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000); st -= pos; st.x *= aspectRatio; st = st * rot(0.9990 * 2. * PI);float amplitude = 0.3400 * mix(0.2, 0.2/(0.5500 + 0.05), 0.25); for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5. * PI * 2.); float cosFactor = cos(i * (5.0 * (0.5500 + 0.1)) * st.y + uTime * 0.025); st.x += amplitude * cosFactor; float sinFactor = sin(i * (5.0 * (0.5500 + 0.1)) * st.x + uTime * 0.025); st.y += amplitude * sinFactor; }st = st * rot(0.9990 * -1. * 2. * PI); st.x /= aspectRatio; st += pos;return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 liquifiedUV = liquify(uv); vec2 normalizedUv = normalize(liquifiedUV - uv); float distanceUv = length(liquifiedUV - uv); float chromAbb = 0.2400 * 0.5;vec2 offsetR = liquifiedUV + chromAbb * normalizedUv * distanceUv; vec2 offsetG = liquifiedUV; vec2 offsetB = liquifiedUV - chromAbb * normalizedUv * distanceUv;vec4 colorR = texture(uTexture, mix(uv, offsetR, 1.0000)); vec4 colorG = texture(uTexture, mix(uv, offsetG, 1.0000)); vec4 colorB = texture(uTexture, mix(uv, offsetB, 1.0000));vec4 color = vec4(colorR.r, colorG.g, colorB.b, colorR.a * colorG.a * colorB.a); fragColor = color;}"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "depth": false,
          "uniforms": {}
        }
      },
      {
        "breakpoints": [],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "liquify",
        "usesPingPong": false,
        "variation": 0.1,
        "speed": 0,
        "trackMouse": 0,
        "mouseMomentum": 0,
        "animating": true,
        "isMask": 0,
        "states": {
          "appear": [],
          "scroll": [
            {
              "type": "scroll",
              "id": "e74548c3-4974-4a55-8315-5cc0a5ae47e5",
              "prop": "variation",
              "progress": 0,
              "momentum": 0.25,
              "range": 0.5,
              "offset": 0.5,
              "mode": "scrollIntoView",
              "delta": 0.01,
              "sceneTop": 0,
              "startScroll": 0,
              "endScroll": 0,
              "lastScrollTop": 0,
              "absScrollValue": true,
              "value": 0.41,
              "breakpoints": [],
              "uniformData": {
                "type": "1f",
                "name": "uAmplitude"
              }
            }
          ],
          "hover": []
        },
        "compiledFragmentShaders": [
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform float uTime; uniform float uAmplitude; uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000); st -= pos; st.x *= aspectRatio; st = st * rot(0.0000 * 2. * PI);float amplitude = uAmplitude * mix(0.2, 0.2/(1.0000 + 0.05), 0.25); for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5. * PI * 2.); float cosFactor = cos(i * (5.0 * (1.0000 + 0.1)) * st.y + uTime * 0.025); st.x += amplitude * cosFactor; float sinFactor = sin(i * (5.0 * (1.0000 + 0.1)) * st.x + uTime * 0.025); st.y += amplitude * sinFactor; }st = st * rot(0.0000 * -1. * 2. * PI); st.x /= aspectRatio; st += pos;return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 liquifiedUV = liquify(uv); vec2 normalizedUv = normalize(liquifiedUV - uv); float distanceUv = length(liquifiedUV - uv); float chromAbb = 0.2000 * 0.5;vec2 offsetR = liquifiedUV + chromAbb * normalizedUv * distanceUv; vec2 offsetG = liquifiedUV; vec2 offsetB = liquifiedUV - chromAbb * normalizedUv * distanceUv;vec4 colorR = texture(uTexture, mix(uv, offsetR, 0.5000)); vec4 colorG = texture(uTexture, mix(uv, offsetG, 0.5000)); vec4 colorB = texture(uTexture, mix(uv, offsetB, 0.5000));vec4 color = vec4(colorR.r, colorG.g, colorB.b, colorR.a * colorG.a * colorB.a); fragColor = color;}"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "depth": false,
          "uniforms": {}
        }
      },
      {
        "breakpoints": [
          {
            "min": 992,
            "max": null,
            "name": "Desktop",
            "props": {
              "angle": 0.99,
              "mix": 0.98,
              "phase": 0.2403,
              "radius": 0.99,
              "pinch": 0.02
            }
          },
          {
            "min": 0,
            "name": "Mobile",
            "props": {
              "phase": 0,
              "radius": 1,
              "pinch": 0.03,
              "angle": 0.35,
              "mix": 1
            },
            "max": 575
          }
        ],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "swirl",
        "usesPingPong": false,
        "speed": 0.07,
        "trackMouse": 0,
        "mouseMomentum": 0,
        "animating": true,
        "isMask": 0,
        "compiledFragmentShaders": [
          "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uRadius; uniform float uAngle; uniform float uPhase; uniform float uTime; uniform float uPinch; uniform float uMix; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float angle = uAngle * 10.; vec2 originalUV = uv; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);uv -= pos; vec2 R = vec2(uv.x * uResolution.x / uResolution.y, uv.y); float distanceToCenter = length(R); distanceToCenter += uPinch*0.5; if (distanceToCenter <= uRadius) { float rot = atan(R.y, R.x) + angle * smoothstep(uRadius, 0., distanceToCenter); uv = vec2(cos(rot + uTime / 20. + uPhase * 6.28), sin(rot + uTime / 20. + uPhase * 6.28)); uv = distanceToCenter * uv + pos; } float t = smoothstep(0., uRadius, distanceToCenter); vec2 mixedUV = mix(uv, originalUV, t);vec4 color = texture(uTexture, mix(vTextureCoord, mixedUV, uMix)); fragColor = color;}"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "depth": false,
          "uniforms": {
            "phase": {
              "name": "uPhase",
              "type": "1f",
              "value": 0
            },
            "radius": {
              "name": "uRadius",
              "type": "1f",
              "value": 0.5
            },
            "pinch": {
              "name": "uPinch",
              "type": "1f",
              "value": 0
            },
            "angle": {
              "name": "uAngle",
              "type": "1f",
              "value": 0.5
            },
            "mix": {
              "name": "uMix",
              "type": "1f",
              "value": 1
            }
          }
        }
      },
      {
        "breakpoints": [
          {
            "props": {
              "fillOpacity": 0.01,
              "refraction": 0.01
            },
            "min": 992,
            "max": null,
            "name": "Desktop"
          },
          {
            "props": {
              "fillOpacity": 0.25,
              "refraction": 1
            },
            "name": "Mobile",
            "max": 575,
            "min": 0
          }
        ],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "sdf_shape",
        "usesPingPong": false,
        "texture": {
          "svgSrc": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/zeztgqdpVtRstL3GsFizCDiEXHi1%2Ftesttruffle.svg?alt=media&token=5b045e7a-c83d-41fe-b9ab-4ee102ff23f8",
          "src": "https://assets.unicorn.studio/images/zeztgqdpVtRstL3GsFizCDiEXHi1/testtruffle_msdf_1743990666912.png",
          "sampler": "uCustomTexture",
          "thumb": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/zeztgqdpVtRstL3GsFizCDiEXHi1%2Ftesttruffle_%40thumbnail.svg?alt=media&token=5b045e7a-c83d-41fe-b9ab-4ee102ff23f8",
          "name": "testtruffle.svg"
        },
        "speed": 0,
        "trackMouseMove": 0,
        "mouseMomentum": 0,
        "trackMouse": 0,
        "animating": false,
        "isMask": 0,
        "compiledFragmentShaders": [
          "#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uRefraction; uniform float uOpacity; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float sdfBox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }vec3 getRepeat(vec3 p) { float spacing = (0.0000 + 1.0000 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.0000 + 1.0000 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scale = max(0.3100, 0.000000001); float scaleFactor = 1.0/scale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (1.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.2484).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.2484).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.2484).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return sdfBox(p, vec3(0.8, 0.8, 1.6 * 0.5000)); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = 1.0 - abs(dot(eyeVector, worldNormal)); return pow(fresnelFactor, power); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + uRefraction * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + uRefraction * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.1100 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { vec3 normal; normal.x = getMergedSDF(p + vec3(eps, 0.0, 0.0)) - getMergedSDF(p - vec3(eps, 0.0, 0.0)); normal.y = getMergedSDF(p + vec3(0.0, eps, 0.0)) - getMergedSDF(p - vec3(0.0, eps, 0.0)); normal.z = getMergedSDF(p + vec3(0.0, 0.0, eps)) - getMergedSDF(p - vec3(0.0, 0.0, eps)); return normalize(normal); }vec3 sampleTexture(vec3 rd, vec3 normal) { if(uOpacity == 1.0) { return vec3(0); }return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (1.0000 + 0.005)) * max(0.3100, 0.000000001); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.0025; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float smoothing = mix(0.5, 4., 1.0000);for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * smoothing); break; }traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return vec4(0); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.0000); vec3 refractionColor = sampleTexture(samplePosition, entryNormal); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333), 1. - uOpacity);vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.1900 * vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.0400 + 0.01); vec3 specularEffect = specFactor * 0.0400 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333) * lightAndShadow, uOpacity); finalColor += combinedEffects;vec4 outputColor = mix(bg, vec4(finalColor, 1.), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0);if(0.3100 <= 0.0001) { col = vec4(0); if(0 == 1) { col = texture(uTexture, vTextureCoord); } fragColor = col; return; }vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "depth": false,
          "uniforms": {
            "fillOpacity": {
              "name": "uOpacity",
              "type": "1f",
              "value": 0
            },
            "refraction": {
              "name": "uRefraction",
              "type": "1f",
              "value": 0.5
            }
          }
        }
      },
      {
        "breakpoints": [],
        "visible": true,
        "aspectRatio": 1,
        "userDownsample": 1,
        "layerType": "effect",
        "type": "bloom",
        "usesPingPong": false,
        "animating": false,
        "mouseMomentum": 0,
        "isMask": 0,
        "compiledFragmentShaders": [
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.0000 - 0.1, 0.0000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.0000 - 0.1, 0.0000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 40., 1.25, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;uniform vec2 uResolution;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 thresholdPass(vec4 color) { color.rgb = pow(color.rgb, vec3(1.0/2.2)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec4 bloom = color * smoothstep(0.0000 - 0.1, 0.0000, luma(color)); return vec4(bloom.rgb, color.a); }vec4 blurCombinePass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { vec4 blurred = blur(uv, vertical, radius, diamond); return (thresholdPass(texture(uBgTexture, uv)) * 0.5 + blurred * intensity); }vec4 getColor(vec4 color) { return blurCombinePass(vTextureCoord, true, 15., 1.1, true); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, false, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float getExponentialWeight(int index) { switch(index) { case 0: return 1.0000000000; case 1: return 0.7165313106; case 2: return 0.5134171190; case 3: return 0.3678794412; case 4: return 0.2636050919; case 5: return 0.1888756057; case 6: return 0.1353352832; case 7: return 0.0969670595; case 8: return 0.0694877157; default: return 0.0; } }vec4 blur(vec2 uv, bool vertical, float radius, bool diamond) { vec4 color = vec4(0.0); float total_weight = 0.0; float aspectRatio = uResolution.x/uResolution.y;vec2 dir; if (diamond) { dir = vertical ? vec2(1, 1) : vec2(1, -1); } else { dir = vertical ? vec2(0, 1) : vec2(1, 0); } dir *= vec2(0.4900, 1. - 0.4900); dir.x /= aspectRatio; vec4 center = texture(uTexture, uv); float center_weight = getExponentialWeight(0); color += center * center_weight; total_weight += center_weight;radius *= 0.2500; for (int i = 1; i <= 8; i++) { float weight = getExponentialWeight(i); float offset = mix(0.015, 0.025, radius) * float(i)/8.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }vec4 blurPass(vec2 uv, bool vertical, float radius, float intensity, bool diamond) { return blur(uv, vertical, radius, diamond); }vec4 getColor(vec4 color) { return blurPass(vTextureCoord, true, 7.5, 1., false); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }",
          "#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }vec4 finalPass(vec4 bloomColor) { float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; bloomColor.rgb *= vec3(1, 1, 1); bloomColor.rgb += dither; bloomColor.a = luma(bloomColor); vec4 sceneColor = texture(uBgTexture, vTextureCoord); vec4 finalColor = mix(sceneColor, sceneColor + bloomColor, 0.0800 * 1.75); return finalColor; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); fragColor = getColor(color); }"
        ],
        "compiledVertexShaders": [
          "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
        ],
        "data": {
          "downSample": 0.5,
          "depth": false,
          "uniforms": {},
          "passes": [
            {
              "prop": "pass",
              "value": 1,
              "downSample": 0.25
            },
            {
              "prop": "pass",
              "value": 2,
              "downSample": 0.25,
              "includeBg": true
            },
            {
              "prop": "pass",
              "value": 3,
              "downSample": 0.25
            },
            {
              "prop": "pass",
              "value": 4,
              "downSample": 0.25,
              "includeBg": true
            },
            {
              "prop": "pass",
              "value": 5,
              "downSample": 0.5
            },
            {
              "prop": "pass",
              "value": 6,
              "downSample": 0.5,
              "includeBg": true
            },
            {
              "prop": "pass",
              "value": 7,
              "includeBg": true
            }
          ]
        }
      }
    ],
    "options": {
      "name": "Flow gradient",
      "fps": 60,
      "dpi": 1.5,
      "scale": 1,
      "includeLogo": false,
      "isProduction": false
    },
    "version": "1.4.14",
    "id": "U4kPgNvjmUJ12rvPTlTJ"
  }
}